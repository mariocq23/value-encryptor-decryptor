"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// eslint-disable-next-line fp/no-events
const events_1 = require("events");
const node_1 = require("@sentry/node");
const delay_1 = __importDefault(require("delay"));
const express_1 = __importDefault(require("express"));
const http_terminator_1 = require("http-terminator");
const serialize_error_1 = require("serialize-error");
const Logger_1 = __importDefault(require("../Logger"));
const states_1 = require("../states");
const utilities_1 = require("../utilities");
const log = Logger_1.default.child({
    namespace: 'factories/createLightship',
});
const defaultConfiguration = {
    detectKubernetes: true,
    gracefulShutdownTimeout: 60000,
    port: 9000,
    shutdownDelay: 5000,
    shutdownHandlerTimeout: 5000,
    signals: [
        'SIGTERM',
        'SIGHUP',
        'SIGINT',
    ],
    terminate: () => {
        // eslint-disable-next-line node/no-process-exit
        process.exit(1);
    },
};
exports.default = (userConfiguration) => {
    let blockingTasks = [];
    let resolveFirstReady;
    const deferredFirstReady = new Promise((resolve) => {
        resolveFirstReady = resolve;
    });
    // eslint-disable-next-line promise/always-return, promise/catch-or-return
    deferredFirstReady.then(() => {
        log.info('service became available for the first time');
    });
    const eventEmitter = new events_1.EventEmitter();
    const beacons = [];
    const shutdownHandlers = [];
    const configuration = {
        ...defaultConfiguration,
        ...userConfiguration,
    };
    if (configuration.gracefulShutdownTimeout < configuration.shutdownHandlerTimeout) {
        throw new Error('gracefulShutdownTimeout cannot be lesser than shutdownHandlerTimeout.');
    }
    let serverIsReady = false;
    let serverIsShuttingDown = false;
    const isServerReady = () => {
        if (blockingTasks.length > 0) {
            log.debug('service is not ready because there are blocking tasks');
            return false;
        }
        return serverIsReady;
    };
    const app = express_1.default();
    const modeIsLocal = configuration.detectKubernetes === true && utilities_1.isKubernetes() === false;
    const server = app.listen(modeIsLocal ? undefined : configuration.port, () => {
        const address = server.address();
        log.info('Lightship HTTP service is running on port %s', address.port);
    });
    const httpTerminator = http_terminator_1.createHttpTerminator({
        server,
    });
    app.use(node_1.Handlers.requestHandler());
    app.get('/health', (incomingMessage, serverResponse) => {
        if (serverIsShuttingDown) {
            serverResponse
                .status(500)
                .send(states_1.SERVER_IS_SHUTTING_DOWN);
        }
        else if (serverIsReady) {
            serverResponse
                .send(states_1.SERVER_IS_READY);
        }
        else {
            serverResponse
                .status(500)
                .send(states_1.SERVER_IS_NOT_READY);
        }
    });
    app.get('/live', (incomingMessage, serverResponse) => {
        if (serverIsShuttingDown) {
            serverResponse
                .status(500)
                .send(states_1.SERVER_IS_SHUTTING_DOWN);
        }
        else {
            serverResponse
                .send(states_1.SERVER_IS_NOT_SHUTTING_DOWN);
        }
    });
    app.get('/ready', (incomingMessage, serverResponse) => {
        if (isServerReady()) {
            serverResponse
                .send(states_1.SERVER_IS_READY);
        }
        else {
            serverResponse
                .status(500)
                .send(states_1.SERVER_IS_NOT_READY);
        }
    });
    app.use(node_1.Handlers.errorHandler());
    const signalNotReady = () => {
        if (serverIsReady === false) {
            log.warn('server is already in a SERVER_IS_NOT_READY state');
        }
        log.info('signaling that the server is not ready to accept connections');
        serverIsReady = false;
    };
    const signalReady = () => {
        if (serverIsShuttingDown) {
            log.warn('server is already shutting down');
            return;
        }
        log.info('signaling that the server is ready');
        if (blockingTasks.length > 0) {
            log.debug('service will not become immediately ready because there are blocking tasks');
        }
        serverIsReady = true;
        if (blockingTasks.length === 0) {
            resolveFirstReady();
        }
    };
    const shutdown = async (nextReady) => {
        if (serverIsShuttingDown) {
            log.warn('server is already shutting down');
            return;
        }
        // @see https://github.com/gajus/lightship/issues/12
        // @see https://github.com/gajus/lightship/issues/25
        serverIsReady = nextReady;
        serverIsShuttingDown = true;
        log.info('received request to shutdown the service');
        if (configuration.shutdownDelay) {
            log.debug('delaying shutdown handler by %d seconds', configuration.shutdownDelay / 1000);
            await delay_1.default(configuration.shutdownDelay);
        }
        let gracefulShutdownTimeoutId;
        if (configuration.gracefulShutdownTimeout !== Number.POSITIVE_INFINITY) {
            gracefulShutdownTimeoutId = setTimeout(() => {
                log.warn('graceful shutdown timeout; forcing termination');
                configuration.terminate();
            }, configuration.gracefulShutdownTimeout);
            gracefulShutdownTimeoutId.unref();
        }
        if (beacons.length) {
            await new Promise((resolve) => {
                const check = () => {
                    log.debug('checking if there are live beacons');
                    if (beacons.length > 0) {
                        log.info({
                            beacons,
                        }, 'program termination is on hold because there are live beacons');
                    }
                    else {
                        log.info('there are no live beacons; proceeding to terminate the Node.js process');
                        eventEmitter.off('beaconStateChange', check);
                        resolve();
                    }
                };
                eventEmitter.on('beaconStateChange', check);
                check();
            });
        }
        if (gracefulShutdownTimeoutId) {
            clearTimeout(gracefulShutdownTimeoutId);
        }
        let shutdownHandlerTimeoutId;
        if (configuration.shutdownHandlerTimeout !== Number.POSITIVE_INFINITY) {
            shutdownHandlerTimeoutId = setTimeout(() => {
                log.warn('shutdown handler timeout; forcing termination');
                configuration.terminate();
            }, configuration.shutdownHandlerTimeout);
            shutdownHandlerTimeoutId.unref();
        }
        log.debug('running %d shutdown handler(s)', shutdownHandlers.length);
        for (const shutdownHandler of shutdownHandlers) {
            try {
                await shutdownHandler();
            }
            catch (error) {
                log.error({
                    error: serialize_error_1.serializeError(error),
                }, 'shutdown handler produced an error');
            }
        }
        if (shutdownHandlerTimeoutId) {
            clearTimeout(shutdownHandlerTimeoutId);
        }
        log.debug('all shutdown handlers have run to completion; proceeding to terminate the Node.js process');
        await httpTerminator.terminate();
        setTimeout(() => {
            log.warn('process did not exit on its own; investigate what is keeping the event loop active');
            configuration.terminate();
        }, 1000)
            .unref();
    };
    if (modeIsLocal) {
        log.warn('shutdown handlers are not used in the local mode');
    }
    else {
        for (const signal of configuration.signals) {
            process.on(signal, () => {
                log.debug({
                    signal,
                }, 'received a shutdown signal');
                shutdown(false);
            });
        }
    }
    const createBeacon = (context) => {
        const beacon = {
            context: context !== null && context !== void 0 ? context : {},
        };
        beacons.push(beacon);
        return {
            die: async () => {
                log.trace({
                    beacon,
                }, 'beacon has been killed');
                beacons.splice(beacons.indexOf(beacon), 1);
                eventEmitter.emit('beaconStateChange');
                await delay_1.default(0);
            },
        };
    };
    return {
        createBeacon,
        isServerReady,
        isServerShuttingDown: () => {
            return serverIsShuttingDown;
        },
        queueBlockingTask: (blockingTask) => {
            blockingTasks.push(blockingTask);
            // eslint-disable-next-line promise/catch-or-return
            blockingTask.then((result) => {
                blockingTasks = blockingTasks.filter((maybeTargetBlockingTask) => {
                    return maybeTargetBlockingTask !== blockingTask;
                });
                if (blockingTasks.length === 0 && serverIsReady === true) {
                    resolveFirstReady();
                }
                return result;
            });
        },
        registerShutdownHandler: (shutdownHandler) => {
            shutdownHandlers.push(shutdownHandler);
        },
        server,
        shutdown: () => {
            return shutdown(false);
        },
        signalNotReady,
        signalReady,
        whenFirstReady: () => {
            return deferredFirstReady;
        },
    };
};
